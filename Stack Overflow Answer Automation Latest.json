{
  "name": "Stack Overflow Answer Automation",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -1632,
        -144
      ],
      "id": "23797e40-91ed-4c3b-a1e0-62d35e9a40ff",
      "name": "Trigger",
      "alwaysOutputData": true,
      "notesInFlow": false
    },
    {
      "parameters": {
        "url": "https://api.stackexchange.com/2.3/questions",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "order",
              "value": "desc"
            },
            {
              "name": "sort",
              "value": "creation"
            },
            {
              "name": "site",
              "value": "stackoverflow"
            },
            {
              "name": "pagesize",
              "value": "10"
            },
            {
              "name": "key",
              "value": "rl_oJs3eYzR5hxMLLNNDVpp8yeRp"
            },
            {
              "name": "tagged",
              "value": "blockchain;ethereum"
            },
            {
              "name": "filter",
              "value": "withbody"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -1328,
        96
      ],
      "id": "441e97b9-48d0-4341-8117-cd5bf84a0316",
      "name": "Blockchain Questions Fetching"
    },
    {
      "parameters": {
        "url": "https://api.stackexchange.com/2.3/questions",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "order",
              "value": "desc"
            },
            {
              "name": "sort",
              "value": "creation"
            },
            {
              "name": "site",
              "value": "stackoverflow"
            },
            {
              "name": "pagesize",
              "value": "10"
            },
            {
              "name": "key",
              "value": "rl_oJs3eYzR5hxMLLNNDVpp8yeRp"
            },
            {
              "name": "tagged",
              "value": " artificial-intelligence;machine-learning"
            },
            {
              "name": "filter",
              "value": "withbody"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -1328,
        -448
      ],
      "id": "da2b26cc-07a5-4f8e-968f-bc2591332820",
      "name": "AI Questions Fetching"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        -1088,
        -176
      ],
      "id": "44e1e515-9c20-42c7-aee3-1631a5f0d339",
      "name": "Merge"
    },
    {
      "parameters": {
        "jsCode": "// Flatten all questions from both responses\nconst allQuestions = [];\n\nfor (const input of $input.all()) {\n  if (input.json.items && Array.isArray(input.json.items)) {\n    allQuestions.push(...input.json.items);\n  }\n}\n\n// Remove duplicates by question_id (in case same question appears in both)\nconst uniqueQuestions = Array.from(\n  new Map(allQuestions.map(q => [q.question_id, q])).values()\n);\n\nreturn uniqueQuestions.map(q => ({ json: q }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -944,
        -176
      ],
      "id": "0d90dc64-b2ab-480e-9e49-0b6590a1fee2",
      "name": "Flatten Array"
    },
    {
      "parameters": {
        "jsCode": "// Get all questions from the merged output\nconst allQuestions = $input.all().map(item => item.json);\n\n// Remove duplicates based on question_id\nconst uniqueQuestions = Array.from(\n  new Map(allQuestions.map(q => [q.question_id, q])).values()\n);\n\n// Return as n8n items\nreturn uniqueQuestions.map(q => ({ json: q }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -816,
        -176
      ],
      "id": "879f859f-ed41-4717-8088-47d946cb2bdd",
      "name": "Remove Duplicates"
    },
    {
      "parameters": {
        "jsCode": "// Get all questions from the merged output\nconst allQuestions = $input.all().map(item => item.json);\n\n// Count total questions\nconst totalCount = allQuestions.length;\n\n// Log the count (visible in n8n execution log)\nconsole.log(`Total questions fetched: ${totalCount}`);\n\n// Return only the count as a single output\nreturn [{ json: { total_questions: totalCount } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        -336
      ],
      "id": "b84c46a8-ab1a-40fa-ad6b-49efc1102417",
      "name": "Count Questions"
    },
    {
      "parameters": {
        "jsCode": "// Get all filtered questions from the previous node\nconst filteredQuestions = $input.all().map(item => item.json);\n\n// Count filtered questions\nconst filteredCount = filteredQuestions.length;\n\n// Log the count (visible in n8n execution log)\nconsole.log(`Number of filtered questions (low/no answers): ${filteredCount}`);\n\n// Return only the count as a single output\nreturn [{ json: { filtered_questions_count: filteredCount } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        0
      ],
      "id": "2aeeb3d3-8557-4532-b2b3-f7a0a108a3ca",
      "name": "Count Filtered Questions"
    },
    {
      "parameters": {
        "jsCode": "// Get all questions from the deduplicated output\nconst allQuestions = $input.all().map(item => item.json);\n\n// Filter questions with no answers or very few answers\n// You can adjust the threshold (currently set to 1 or fewer answers)\nconst threshold = 1; // Change this to 0 for only unanswered, or 2 for 2 or fewer answers\n\nconst filteredQuestions = allQuestions.filter(question => {\n  return question.answer_count <= threshold;\n});\n\n// Log the results\nconsole.log(`Total unique questions: ${allQuestions.length}`);\nconsole.log(`Questions with ${threshold} or fewer answers: ${filteredQuestions.length}`);\n\n// Return filtered questions\nreturn filteredQuestions.map(q => ({ json: q }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -640,
        -176
      ],
      "id": "388756c0-87e7-45cf-8394-ec94cb07dbd0",
      "name": "Filter Questions by Threshold"
    },
    {
      "parameters": {
        "jsCode": "// Code node to display questions data in JSON format\n// Place this after your filter node or any node that outputs questions\n\n// Get all questions from the input\nconst questions = $input.all().map(item => item.json);\n\n// Extract only the essential question data fields\nconst questionsData = questions.map(question => ({\n  question_id: question.question_id,\n  title: question.title,\n  link: question.link,\n  tags: question.tags,\n  is_answered: question.is_answered,\n  answer_count: question.answer_count,\n  view_count: question.view_count,\n  score: question.score,\n  creation_date: question.creation_date,\n  last_activity_date: question.last_activity_date,\n  body: question.body\n}));\n\n// Return as n8n items with clean JSON structure\nreturn questionsData.map(q => ({ json: q }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -464,
        -176
      ],
      "id": "a29f1785-6594-4af1-9e57-b677a1f0c309",
      "name": "Display Questions"
    },
    {
      "parameters": {
        "jsCode": "// Code node to display questions data in JSON format\n// Place this after your filter node or any node that outputs questions\n\n// Function to convert HTML to plain text\nfunction htmlToText(html) {\n  if (!html) return '';\n  \n  let text = html;\n  \n  // Decode common HTML entities\n  text = text.replace(/&quot;/g, '\"');\n  text = text.replace(/&#39;/g, \"'\");\n  text = text.replace(/&amp;/g, '&');\n  text = text.replace(/&lt;/g, '<');\n  text = text.replace(/&gt;/g, '>');\n  text = text.replace(/&nbsp;/g, ' ');\n  text = text.replace(/&#x27;/g, \"'\");\n  text = text.replace(/&#x2F;/g, '/');\n  \n  // Decode numeric HTML entities (like &#39;)\n  text = text.replace(/&#(\\d+);/g, (match, dec) => String.fromCharCode(dec));\n  \n  // Decode hex HTML entities (like &#x27;)\n  text = text.replace(/&#x([0-9a-fA-F]+);/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));\n  \n  // Remove HTML tags\n  text = text.replace(/<[^>]*>/g, '');\n  \n  // Replace multiple whitespace/newlines with single space, then trim\n  text = text.replace(/\\s+/g, ' ').trim();\n  \n  return text;\n}\n\n// Get all questions from the input\nconst questions = $input.all().map(item => item.json);\n\n// Extract only the essential question data fields\nconst questionsData = questions.map(question => ({\n  title: question.title,\n  link: question.link,\n  tags: question.tags,\n  body: htmlToText(question.body) // Convert HTML body to plain text\n}));\n\n// Return as n8n items with clean JSON structure\nreturn questionsData.map(q => ({ json: q }));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -272,
        -176
      ],
      "id": "ccba4e6a-ddaa-4d0c-b6e2-6792284928fa",
      "name": "Parse Questions"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=You are a senior Blockchain & AI engineer and technical writer.\n\nYou receive StackOverflow questions and must generate a full blog article that SOLVES them.\n\nQuestion title:\n{{$json[\"title\"]}}\n\nQuestion body (plain text):\n{{$json[\"body\"]}}\n\nTags (string or array):\n{{$json[\"tags\"]}}\n\nWrite one AI-generated blog post that:\n- Explains the problem clearly in simple language.\n- Provides a detailed, step-by-step solution.\n- Includes at least TWO code snippets where helpful in python and javascript\n- Follows this fixed template:\n  1. Introduction (what the problem is and why it matters)\n  2. Problem Breakdown\n  3. Step-by-Step Solution\n  4. Code Examples in python and javascript\n  5. Common Pitfalls / Gotchas\n  6. Conclusion and Next Steps\n\nReturn the result as plain markdown text with proper headings and paragraphs. Use standard markdown formatting:\n- Use # for main title\n- Use ## for section headings\n- Use ### for subsections if needed\n- Use code blocks with language identifiers for code snippets\n- Use regular paragraphs for text content\n- Do not escape any characters or use JSON formatting\n- Output should be clean, readable markdown that can be directly used\n\nFormat your response as follows:\n\n# [Blog Post Title]\n\n## 1. Introduction\n\n[Introduction paragraph explaining what the problem is and why it matters]\n\n## 2. Problem Breakdown\n\n[Detailed breakdown of the problem]\n\n## 3. Step-by-Step Solution\n\n[Step-by-step solution with clear instructions]\n\n## 4. Code Examples in python and javascript\n\n[At least two code examples with proper code blocks]\n\n## 5. Common Pitfalls / Gotchas\n\n[Common issues and how to avoid them]\n\n## 6. Conclusion and Next Steps\n\n[Conclusion and recommendations for next steps]",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        -80,
        -176
      ],
      "id": "c7478c97-a8e1-4c11-9def-020af9c2eb97",
      "name": "Content Generator"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-mini",
          "mode": "list",
          "cachedResultName": "gpt-4.1-mini"
        },
        "responsesApiEnabled": false,
        "options": {
          "maxTokens": 2000
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        -80,
        32
      ],
      "id": "07241a76-fbcc-441f-bbcc-97351dd09702",
      "name": "GPT 4.1 mini",
      "credentials": {
        "openAiApi": {
          "id": "H5LXr3raFFEHNnlb",
          "name": "OpenAi account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// Input: items with LLM response containing blog post markdown\n// Output: one item per input with parsed blog post content\n\nconst items = $input.all();\nconst output = [];\nlet successCount = 0;\nlet failCount = 0;\n\n// Helper: Clean text and handle escape sequences\nfunction cleanText(text) {\n  if (!text) return '';\n  return text\n    .replace(/\\\\n/g, '\\n')\n    .replace(/\\\\r/g, '\\r')\n    .replace(/\\\\t/g, '\\t')\n    .replace(/\\\\\"/g, '\"')\n    .replace(/\\\\\\\\/g, '\\\\')\n    .replace(/&#39;/g, \"'\")\n    .replace(/&quot;/g, '\"')\n    .replace(/&amp;/g, '&')\n    .replace(/&lt;/g, '<')\n    .replace(/&gt;/g, '>');\n}\n\n// Helper: Detect if content is a blog post (starts with markdown heading)\nfunction isBlogPost(text) {\n  if (!text) return false;\n  const trimmed = text.trim();\n  // Check for markdown heading at start\n  return trimmed.startsWith('#') || \n         /^#{1,6}\\s+.+/m.test(trimmed) ||\n         trimmed.includes('## 1. Introduction') ||\n         trimmed.includes('## Introduction');\n}\n\n// Helper: Extract title from markdown content\nfunction extractTitle(content) {\n  if (!content) return '';\n  \n  // Look for first H1 heading\n  const h1Match = content.match(/^#\\s+(.+)$/m);\n  if (h1Match) {\n    return h1Match[1].trim();\n  }\n  \n  // Fallback: look for any heading\n  const headingMatch = content.match(/^#{1,6}\\s+(.+)$/m);\n  if (headingMatch) {\n    return headingMatch[1].trim();\n  }\n  \n  return '';\n}\n\n// Helper: Try to extract JSON if present\nfunction tryExtractJSON(str) {\n  try {\n    // Remove markdown code fences\n    let cleaned = str.replace(/^```(?:json)?\\s*/i, '').replace(/\\s*```$/i, '').trim();\n    \n    // Find JSON object boundaries\n    const firstBrace = cleaned.indexOf('{');\n    const lastBrace = cleaned.lastIndexOf('}');\n    \n    if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {\n      const jsonStr = cleaned.substring(firstBrace, lastBrace + 1);\n      return JSON.parse(jsonStr);\n    }\n  } catch (e) {\n    // Not valid JSON, return null\n  }\n  return null;\n}\n\n// Process each item\nfor (let postIndex = 0; postIndex < items.length; postIndex++) {\n  const item = items[postIndex];\n  \n  // Get raw LLM output from various possible locations\n  let rawContent = item.json?.text ?? \n                   item.json?.response ?? \n                   item.json?.content ?? \n                   item.json?.output ??\n                   item.json?.message ??\n                   item.json;\n  \n  // Convert to string if needed\n  let contentStr = typeof rawContent === 'string' ? rawContent : JSON.stringify(rawContent);\n  \n  // Clean the content\n  contentStr = cleanText(contentStr);\n  \n  let blog_post_content = '';\n  let blog_post_title = '';\n  let parsed = null;\n  let parseError = null;\n  let parse_ok = false;\n  \n  // Strategy 1: Check if it's wrapped in JSON\n  parsed = tryExtractJSON(contentStr);\n  \n  if (parsed && parsed.text) {\n    // LLM returned JSON with text field\n    blog_post_content = cleanText(parsed.text);\n    blog_post_title = extractTitle(blog_post_content);\n    parse_ok = true;\n    successCount++;\n  } else if (isBlogPost(contentStr)) {\n    // LLM returned raw markdown blog post (most common case based on your data)\n    blog_post_content = contentStr;\n    blog_post_title = extractTitle(blog_post_content);\n    parse_ok = true;\n    successCount++;\n  } else {\n    // Content doesn't look like a blog post - might be partial/error\n    parseError = \"Content does not appear to be a complete blog post\";\n    \n    // Still try to salvage what we can\n    blog_post_content = contentStr;\n    blog_post_title = extractTitle(contentStr);\n    \n    failCount++;\n  }\n  \n  // Additional validation: check if content is substantial\n  const wordCount = blog_post_content.split(/\\s+/).length;\n  const hasIntroSection = blog_post_content.includes('## 1. Introduction') || \n                          blog_post_content.includes('## Introduction');\n  \n  if (parse_ok && wordCount < 100) {\n    parseError = `Content too short (${wordCount} words) - likely incomplete`;\n    parse_ok = false;\n  }\n  \n  if (parse_ok && !hasIntroSection && wordCount > 50) {\n    // Warn but don't fail if there's substantial content\n    parseError = \"Warning: No introduction section found, but content appears substantial\";\n  }\n  \n  // Create output item\n  output.push({\n    json: {\n      post_number: postIndex + 1,\n      parse_ok: parse_ok,\n      parse_error: parseError,\n      blog_post_title: blog_post_title,\n      blog_post_content: blog_post_content,\n      word_count: wordCount,\n      has_introduction: hasIntroSection,\n      content_preview: blog_post_content.substring(0, 200) + '...',\n      raw_length: contentStr.length,\n    },\n  });\n}\n\n// Log summary\nconsole.log(`Parse Summary: ${successCount} succeeded, ${failCount} failed out of ${items.length} total`);\n\nreturn output;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        -176
      ],
      "id": "2309a877-8f0b-44c3-9fe7-50b3ebb057da",
      "name": "Parse Content"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => ({\n  json: {\n    post_number: item.json.post_number,\n    title: item.json.blog_post_title,\n    content: item.json.blog_post_content\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        400,
        -176
      ],
      "id": "148b750b-7b62-471a-954c-9e9dfbc67c84",
      "name": "Fetch Post Content"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all();\n\nreturn items.map(item => {\n  const content = item.json.content;\n  \n  // Extract sections\n  const getSectionAfter = (pattern) => {\n    const regex = new RegExp(`${pattern}([\\\\s\\\\S]*?)(?=##\\\\s+\\\\d+\\\\.|$)`, 'i');\n    const match = content.match(regex);\n    return match ? match[1].trim() : '';\n  };\n  \n  return {\n    json: {\n      post_number: item.json.post_number,\n      title: item.json.title,\n      //content: content, // Full blog post content\n      post_content: getSectionAfter('##\\\\s*1\\\\.\\\\s*Introduction'),\n      solution_steps: getSectionAfter('##\\\\s*3\\\\.\\\\s*Step-by-Step Solution'),\n      code_snippets: getSectionAfter('##\\\\s*4\\\\.\\\\s*Code Examples'),\n      security_pitfalls: getSectionAfter('##\\\\s*5\\\\.\\\\s*Common Pitfalls')\n    }\n  };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        -176
      ],
      "id": "c2fe1594-d351-4543-9cd4-e63cbf3c2ebd",
      "name": "Extract Content Data"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node - Enhanced cleaning of markdown and special characters from post_content, solution_steps, and security_pitfalls\n\n// Function to clean a string by stripping markdown and special chars\nfunction cleanText(text) {\n    if (typeof text !== 'string') return text;\n    \n    let cleaned = text;\n    \n    // Remove bold: **text**\n    cleaned = cleaned.replace(/\\*\\*(.*?)\\*\\*/g, '$1');\n    \n    // Remove italic: *text*\n    cleaned = cleaned.replace(/\\*(.*?)\\*/g, '$1');\n    \n    // Remove headings: # Heading\n    cleaned = cleaned.replace(/^#+\\s*/gm, '');\n    \n    // Remove bullets: - item or * item\n    cleaned = cleaned.replace(/^\\s*[-*]\\s+/gm, '');\n    \n    // Remove quotes: > quote\n    cleaned = cleaned.replace(/^\\s*>\\s*/gm, '');\n    \n    // Remove inline code: `code`\n    cleaned = cleaned.replace(/`(.*?)`/g, '$1');\n    \n    // Remove horizontal lines: --- or ***\n    cleaned = cleaned.replace(/^\\s*---\\s*$/gm, '');\n    cleaned = cleaned.replace(/^\\s*\\*\\*\\*\\s*$/gm, '');\n    \n    // Remove backslashes: \\ or \\\\\n    cleaned = cleaned.replace(/\\\\\\\\/g, '');\n    cleaned = cleaned.replace(/\\\\/g, '');\n    \n    // Remove other specials like / or [\n    cleaned = cleaned.replace(/\\//g, '');\n    cleaned = cleaned.replace(/\\[/g, '');\n    cleaned = cleaned.replace(/\\]/g, '');\n    \n    // Normalize line endings and collapse newlines to single space\n    cleaned = cleaned.replace(/\\r\\n/g, '\\n');\n    cleaned = cleaned.replace(/\\r/g, '\\n');\n    cleaned = cleaned.replace(/\\n+/g, ' ');\n    \n    // Collapse multiple spaces to single\n    cleaned = cleaned.replace(/\\s+/g, ' ');\n    \n    // Trim whitespace\n    return cleaned.trim();\n}\n\n// Process each item in the input\nreturn items.map(item => {\n    const json = item.json;\n\n    // Clean the three target fields if they exist\n    if (json.post_content) {\n        json.post_content = cleanText(json.post_content);\n    }\n    \n    if (json.solution_steps) {\n        json.solution_steps = cleanText(json.solution_steps);\n    }\n    \n    if (json.security_pitfalls) {\n        json.security_pitfalls = cleanText(json.security_pitfalls);\n    }\n\n    return {\n        json: json,\n        // Preserve pairedItem if needed (important for n8n routing)\n        pairedItem: item.pairedItem,\n    };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        128,
        48
      ],
      "id": "762a5978-cd79-4376-a64d-d9cd6dc56215",
      "name": "Clean Post Content"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code Node - Clean code_snippets by extracting and dedenting code blocks with language\n\n// Simple dedent function\nfunction dedent(code) {\n    const lines = code.split('\\n').filter(line => line.trim() !== '');\n    if (lines.length === 0) return code.trim();\n    \n    const minIndent = Math.min(...lines.map(line => line.match(/^\\s*/)[0].length));\n    return code.split('\\n').map(line => line.slice(minIndent)).join('\\n').trim();\n}\n\n// Function to clean code_snippets: extract blocks with language\nfunction cleanCodeSnippets(text) {\n    if (typeof text !== 'string') return text;\n    \n    const pattern = /```(\\w+)?\\n([\\s\\S]*?)```/g;\n    let match;\n    const blocks = [];\n    \n    while ((match = pattern.exec(text)) !== null) {\n        const lang = match[1] || ''; // Language or empty\n        const code = dedent(match[2]);\n        const block = lang ? `${lang}\\n${code}` : code;\n        blocks.push(block);\n    }\n    \n    // Join with separator\n    return blocks.join('\\n\\n---\\n\\n');\n}\n\n// Process each item in the input\nreturn items.map(item => {\n    const json = item.json;\n\n    // Clean only the code_snippets field if it exists\n    if (json.code_snippets) {\n        json.code_snippets = cleanCodeSnippets(json.code_snippets);\n    }\n\n    return {\n        json: json,\n        // Preserve pairedItem if needed (important for n8n routing)\n        pairedItem: item.pairedItem,\n    };\n});"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        320,
        48
      ],
      "id": "5905464a-4127-4ae6-b69b-f27f359e11be",
      "name": "Clean Code Snippets"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Clean code_snippets section\n * \n * This code cleans code snippets by removing unnecessary characters:\n * - Removes \"in python and javascript\" prefixes\n * - Normalizes markdown separators\n * - Removes extra whitespace\n * - Formats code blocks properly\n * \n * Input: Blog post items with 'code_snippets' field\n * Output: Same items with cleaned 'code_snippets'\n */\n\n// Main cleaning function\nfunction cleanCodeSnippets(codeSnippets) {\n    if (!codeSnippets || typeof codeSnippets !== 'string') {\n        return '';\n    }\n    \n    let text = codeSnippets.trim();\n    \n    // Remove \"in python and javascript\" prefixes at the start\n    text = text.replace(/^in\\s+(python|javascript)\\s+and\\s+(python|javascript)\\s*\\n+/i, '');\n    text = text.replace(/^in\\s+(python|javascript)\\s*\\n+/i, '');\n    \n    // Remove standalone \"in python and javascript\" anywhere\n    text = text.replace(/\\n+in\\s+(python|javascript)\\s+and\\s+(python|javascript)\\s*\\n+/gi, '\\n\\n');\n    \n    // Normalize markdown separators to single \"---\"\n    text = text.replace(/-{3,}/g, '---');\n    \n    // Remove multiple consecutive newlines (more than 2)\n    text = text.replace(/\\n{3,}/g, '\\n\\n');\n    \n    // Process line by line\n    const lines = text.split('\\n');\n    const cleanedLines = [];\n    let prevEmpty = false;\n    let prevWasSeparator = false;\n    \n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        const stripped = line.trim();\n        \n        // Skip multiple consecutive empty lines\n        if (!stripped) {\n            if (!prevEmpty && !prevWasSeparator) {\n                cleanedLines.push('');\n                prevEmpty = true;\n            }\n            prevWasSeparator = false;\n            continue;\n        }\n        \n        prevEmpty = false;\n        \n        // Handle separator lines\n        if (stripped === '---' || (stripped.startsWith('---') && stripped.length <= 5)) {\n            if (!prevWasSeparator) {\n                cleanedLines.push('---');\n                prevWasSeparator = true;\n            }\n            continue;\n        }\n        \n        prevWasSeparator = false;\n        \n        // Keep section headers like \"### Python:\" or \"### JavaScript:\"\n        if (/^###\\s+(Python|JavaScript|C#|C\\+\\+|Solidity|Bash|Shell)/i.test(stripped)) {\n            cleanedLines.push(stripped);\n            continue;\n        }\n        \n        // Keep the line as is (preserve indentation for code)\n        cleanedLines.push(line);\n    }\n    \n    // Join lines back\n    let cleaned = cleanedLines.join('\\n');\n    \n    // Remove leading/trailing whitespace\n    cleaned = cleaned.trim();\n    \n    // Ensure proper spacing around code blocks\n    cleaned = cleaned.replace(/([^\\n])\\n```/g, '$1\\n\\n```');\n    cleaned = cleaned.replace(/```\\n([^\\n])/g, '```\\n\\n$1');\n    \n    // Clean up any remaining multiple newlines\n    cleaned = cleaned.replace(/\\n{3,}/g, '\\n\\n');\n    \n    // Remove trailing separators\n    cleaned = cleaned.replace(/\\n+---+?\\s*$/g, '');\n    \n    // Final trim\n    return cleaned.trim();\n}\n\n// n8n execution\nconst items = $input.all();\nconst outputItems = [];\n\nfor (const item of items) {\n    const blogPost = item.json;\n    \n    // Clean code_snippets if it exists\n    if (blogPost.code_snippets) {\n        const original = blogPost.code_snippets;\n        const cleaned = cleanCodeSnippets(original);\n        \n        // Create new item with cleaned code_snippets\n        const cleanedItem = {\n            json: {\n                ...blogPost,\n                code_snippets: cleaned\n            }\n        };\n        \n        outputItems.push(cleanedItem);\n    } else {\n        // If no code_snippets, pass through as is\n        outputItems.push(item);\n    }\n}\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        528,
        48
      ],
      "id": "8fda619f-4673-462f-8c36-a37d38853ee5",
      "name": "Clean Code Snippets 2"
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "/**\n * n8n Code Node: Convert Blog Post to HTML\n * \n * Converts blog post JSON data into well-formatted HTML\n * \n * Input: Blog post items with all fields\n * Output: Items with 'html_content' field\n */\n\nfunction convertToHTML(blogPost) {\n    const title = blogPost.title || 'Untitled';\n    const postNumber = blogPost.post_number || '';\n    const postContent = blogPost.post_content || '';\n    const solutionSteps = blogPost.solution_steps || '';\n    const codeSnippets = blogPost.code_snippets || '';\n    const securityPitfalls = blogPost.security_pitfalls || '';\n    \n    let html = '<article class=\"blog-post\">\\n';\n    \n    // Post Number (optional)\n    if (postNumber) {\n        html += `  <div class=\"post-number\">Post #${postNumber}</div>\\n`;\n    }\n    \n    // Title\n    html += `  <h1 class=\"post-title\">${escapeHtml(title)}</h1>\\n\\n`;\n    \n    // Post Content\n    if (postContent) {\n        html += '  <div class=\"post-content\">\\n';\n        const paragraphs = postContent.split(/\\n\\n+/).filter(p => p.trim());\n        paragraphs.forEach(para => {\n            html += `    <p>${formatParagraph(para)}</p>\\n`;\n        });\n        html += '  </div>\\n\\n';\n    }\n    \n    // Solution Steps\n    if (solutionSteps) {\n        html += '  <div class=\"solution-steps\">\\n';\n        html += '    <h2>Solution Steps</h2>\\n';\n        html += formatSolutionSteps(solutionSteps);\n        html += '  </div>\\n\\n';\n    }\n    \n    // Code Snippets\n    if (codeSnippets) {\n        html += '  <div class=\"code-snippets\">\\n';\n        html += '    <h2>Code Examples</h2>\\n';\n        html += formatCodeSnippets(codeSnippets);\n        html += '  </div>\\n\\n';\n    }\n    \n    // Security Pitfalls\n    if (securityPitfalls) {\n        html += '  <div class=\"security-pitfalls\">\\n';\n        html += '    <h2>Common Pitfalls and Gotchas</h2>\\n';\n        html += formatSecurityPitfalls(securityPitfalls);\n        html += '  </div>\\n\\n';\n    }\n    \n    html += '</article>';\n    \n    return html;\n}\n\nfunction escapeHtml(text) {\n    const map = {\n        '&': '&amp;',\n        '<': '&lt;',\n        '>': '&gt;',\n        '\"': '&quot;',\n        \"'\": '&#039;'\n    };\n    return text.replace(/[&<>\"']/g, m => map[m]);\n}\n\nfunction formatParagraph(text) {\n    // Clean up the text\n    let formatted = escapeHtml(text.trim());\n    // Remove code block markers if any\n    formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');\n    return formatted;\n}\n\nfunction formatSolutionSteps(steps) {\n    let html = '    <ol class=\"steps-list\">\\n';\n    \n    // Split by \"Step\" pattern\n    const stepPattern = /Step\\s+\\d+:/gi;\n    const parts = steps.split(stepPattern);\n    const stepMatches = steps.match(stepPattern);\n    \n    if (stepMatches && stepMatches.length > 0) {\n        for (let i = 0; i < stepMatches.length; i++) {\n            const stepTitle = stepMatches[i].trim();\n            const stepContent = parts[i + 1] || '';\n            \n            html += '      <li class=\"step-item\">\\n';\n            html += `        <strong>${escapeHtml(stepTitle)}</strong>\\n`;\n            \n            // Format step content\n            const content = stepContent.trim();\n            if (content) {\n                // Check for sub-items or code blocks\n                if (content.includes('\\n')) {\n                    const lines = content.split('\\n').filter(l => l.trim());\n                    html += '        <div class=\"step-content\">\\n';\n                    lines.forEach(line => {\n                        const trimmed = line.trim();\n                        if (trimmed.startsWith('-') || trimmed.match(/^\\d+\\./)) {\n                            html += `          <p>${formatParagraph(trimmed)}</p>\\n`;\n                        } else {\n                            html += `          <p>${formatParagraph(trimmed)}</p>\\n`;\n                        }\n                    });\n                    html += '        </div>\\n';\n                } else {\n                    html += `        <p>${formatParagraph(content)}</p>\\n`;\n                }\n            }\n            \n            html += '      </li>\\n';\n        }\n    } else {\n        // Fallback: treat as regular text\n        const paragraphs = steps.split(/\\n\\n+/).filter(p => p.trim());\n        paragraphs.forEach(para => {\n            html += `      <li><p>${formatParagraph(para)}</p></li>\\n`;\n        });\n    }\n    \n    html += '    </ol>\\n';\n    return html;\n}\n\nfunction formatCodeSnippets(codeSnippets) {\n    let html = '';\n    \n    // Split by separators (---)\n    const sections = codeSnippets.split(/---+/).filter(s => s.trim());\n    \n    sections.forEach(section => {\n        const trimmed = section.trim();\n        \n        // Check if it starts with a language identifier\n        const langMatch = trimmed.match(/^(\\w+)\\n/);\n        if (langMatch) {\n            const language = langMatch[1];\n            const code = trimmed.substring(language.length).trim();\n            \n            html += '    <div class=\"code-block-wrapper\">\\n';\n            html += `      <div class=\"code-header\">${escapeHtml(language)}</div>\\n`;\n            html += '      <pre><code class=\"language-' + escapeHtml(language.toLowerCase()) + '\">';\n            html += escapeHtml(code);\n            html += '</code></pre>\\n';\n            html += '    </div>\\n\\n';\n        } else {\n            // Check for markdown code blocks\n            const codeBlockMatch = trimmed.match(/```(\\w+)?\\n([\\s\\S]*?)```/);\n            if (codeBlockMatch) {\n                const language = codeBlockMatch[1] || 'text';\n                const code = codeBlockMatch[2];\n                \n                html += '    <div class=\"code-block-wrapper\">\\n';\n                html += `      <div class=\"code-header\">${escapeHtml(language)}</div>\\n`;\n                html += '      <pre><code class=\"language-' + escapeHtml(language.toLowerCase()) + '\">';\n                html += escapeHtml(code);\n                html += '</code></pre>\\n';\n                html += '    </div>\\n\\n';\n            } else {\n                // Plain text code\n                html += '    <div class=\"code-block-wrapper\">\\n';\n                html += '      <pre><code>';\n                html += escapeHtml(trimmed);\n                html += '</code></pre>\\n';\n                html += '    </div>\\n\\n';\n            }\n        }\n    });\n    \n    return html;\n}\n\nfunction formatSecurityPitfalls(pitfalls) {\n    let html = '    <ul class=\"pitfalls-list\">\\n';\n    \n    // Split by common patterns\n    const items = pitfalls.split(/Gotchas|Gotcha|Pitfall|Note:/i);\n    \n    if (items.length > 1) {\n        // Skip first item (usually empty or \"Gotchas\" text)\n        for (let i = 1; i < items.length; i++) {\n            const item = items[i].trim();\n            if (item) {\n                // Check if it has a colon (title: description format)\n                const colonIndex = item.indexOf(':');\n                if (colonIndex > 0 && colonIndex < 50) {\n                    const title = item.substring(0, colonIndex).trim();\n                    const description = item.substring(colonIndex + 1).trim();\n                    \n                    html += '      <li class=\"pitfall-item\">\\n';\n                    html += `        <strong>${escapeHtml(title)}:</strong>\\n`;\n                    html += `        <span>${formatParagraph(description)}</span>\\n`;\n                    html += '      </li>\\n';\n                } else {\n                    html += `      <li>${formatParagraph(item)}</li>\\n`;\n                }\n            }\n        }\n    } else {\n        // Fallback: split by periods or newlines\n        const sentences = pitfalls.split(/\\.\\s+/).filter(s => s.trim());\n        sentences.forEach(sentence => {\n            html += `      <li>${formatParagraph(sentence)}</li>\\n`;\n        });\n    }\n    \n    html += '    </ul>\\n';\n    return html;\n}\n\n// n8n execution - Run Once for Each Item mode\nconst item = $input.item;\nconst blogPost = item.json;\n\n// Convert to HTML\nconst htmlContent = convertToHTML(blogPost);\n\n// Return item with HTML content\nreturn {\n    json: {\n        ...blogPost,\n        html_content: htmlContent\n    }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        816,
        48
      ],
      "id": "804bedae-06a9-43bb-8435-030cf0613dc4",
      "name": "Post -> HTML"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Convert Blog Posts to HTML Files\n * \n * Mode: Run Once for All Items\n * Language: JavaScript\n * \n * This code converts blog post JSON data into HTML files.\n * Returns binary data that can be saved using n8n's file nodes.\n * \n * IMPORTANT: n8n Code Node runs in a sandbox and cannot access fs/path directly.\n * Use a \"Read/Write Files from Disk\" node after this to save the files.\n */\n\n// Get input data\nconst inputItems = $input.all();\n\n// HTML template with CSS styling (matching your Python script)\nconst HTML_TEMPLATE = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<meta name=\"description\" content=\"{{TITLE}}\">\n<title>{{TITLE}}</title>\n<style>\n/* Blog Post HTML Styles */\n* {\n    box-sizing: border-box;\n}\n\nbody {\n    margin: 0;\n    padding: 0;\n    background: #f5f5f5;\n}\n\n.blog-post {\n    max-width: 900px;\n    margin: 0 auto;\n    padding: 40px 20px;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    line-height: 1.7;\n    color: #333;\n    background: #fff;\n    box-shadow: 0 2px 4px rgba(0,0,0,0.1);\n}\n\n.post-number {\n    font-size: 14px;\n    color: #666;\n    margin-bottom: 10px;\n    font-weight: 500;\n    text-transform: uppercase;\n    letter-spacing: 0.5px;\n}\n\n.post-title {\n    font-size: 36px;\n    font-weight: 700;\n    color: #1a1a1a;\n    margin: 0 0 30px 0;\n    line-height: 1.3;\n}\n\n.post-content {\n    margin-bottom: 40px;\n}\n\n.post-content p {\n    margin-bottom: 20px;\n    font-size: 17px;\n    color: #444;\n}\n\n.post-content code {\n    background: #f5f5f5;\n    padding: 2px 6px;\n    border-radius: 3px;\n    font-size: 15px;\n    font-family: 'Courier New', monospace;\n    color: #d63384;\n}\n\n.solution-steps {\n    margin-bottom: 40px;\n    padding: 30px;\n    background: #f8f9fa;\n    border-radius: 8px;\n    border-left: 4px solid #007bff;\n}\n\n.solution-steps h2 {\n    margin-top: 0;\n    margin-bottom: 20px;\n    color: #007bff;\n}\n\n.solution-steps ol {\n    margin: 0;\n    padding-left: 20px;\n}\n\n.solution-steps li {\n    margin-bottom: 16px;\n}\n\n.code-examples {\n    margin-bottom: 40px;\n}\n\n.code-examples h2 {\n    margin-bottom: 20px;\n    color: #1a1a1a;\n}\n\n.code-block-wrapper {\n    margin-bottom: 24px;\n    border-radius: 6px;\n    overflow: hidden;\n    border: 1px solid #e1e4e8;\n    background: #0d1117;\n    box-shadow: 0 2px 8px rgba(0,0,0,0.1);\n}\n\n.code-header {\n    padding: 8px 12px;\n    font-size: 13px;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    color: #c9d1d9;\n    background: #161b22;\n    font-weight: 600;\n}\n\npre {\n    margin: 0;\n    padding: 14px 16px;\n    overflow-x: auto;\n    background: #0d1117;\n    color: #c9d1d9;\n    font-family: 'JetBrains Mono', 'Fira Code', 'Menlo', 'Monaco', 'Consolas', 'Courier New', monospace;\n    font-size: 13px;\n    line-height: 1.5;\n}\n\npre code {\n    background: transparent;\n    padding: 0;\n    color: inherit;\n    font-size: inherit;\n}\n\n.security-pitfalls {\n    margin-top: 40px;\n    padding: 24px 20px;\n    border-radius: 8px;\n    background: #fff4e6;\n    border: 1px solid #ffd8a8;\n    border-left: 4px solid #ff9800;\n}\n\n.security-pitfalls h2 {\n    margin-top: 0;\n    margin-bottom: 20px;\n    color: #d9480f;\n}\n\n.security-pitfalls p {\n    margin-bottom: 15px;\n}\n\n@media (max-width: 768px) {\n    .blog-post {\n        padding: 20px 15px;\n    }\n    .post-title {\n        font-size: 28px;\n    }\n    .solution-steps, .security-pitfalls {\n        padding: 20px 15px;\n    }\n}\n</style>\n</head>\n<body>\n{{BODY}}\n</body>\n</html>`;\n\n// Function to sanitize filename\nfunction sanitizeFilename(text) {\n    return text\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/^-+|-+$/g, '')\n        .substring(0, 50);\n}\n\n// Helper function to escape HTML in title\nfunction escapeHtml(text) {\n    if (!text) return '';\n    return String(text)\n        .replace(/&/g, '&amp;')\n        .replace(/</g, '&lt;')\n        .replace(/>/g, '&gt;')\n        .replace(/\"/g, '&quot;')\n        .replace(/'/g, '&#039;');\n}\n\n// Main processing function\nfunction processBlogPosts() {\n    const results = [];\n    \n    // Process each blog post\n    inputItems.forEach((item, index) => {\n        try {\n            const post = item.json;\n            const postNumber = post.post_number || 'unknown';\n            const title = post.title || 'Untitled Blog Post';\n            const htmlContent = post.html_content || '';\n            \n            // Generate filename\n            const titleSlug = sanitizeFilename(title);\n            const filename = `post-${postNumber}-${titleSlug}.html`;\n            \n            // Create full HTML document (escape title for safety)\n            const escapedTitle = escapeHtml(title);\n            const fullHTML = HTML_TEMPLATE\n                .replace(/{{TITLE}}/g, escapedTitle)\n                .replace('{{BODY}}', htmlContent);\n            \n            // Return JSON data with HTML content and file info\n            // Use \"Read/Write Files from Disk\" node after this to save files\n            results.push({\n                json: {\n                    ...post,\n                    html_filename: filename,\n                    html_file_path: `C:\\\\Users\\\\PC\\\\Desktop\\\\Workflow\\\\${filename}`,\n                    full_html_document: fullHTML,\n                    file_size_bytes: fullHTML.length,\n                    ready_to_save: true\n                }\n            });\n            \n        } catch (error) {\n            results.push({\n                json: {\n                    error: error.message,\n                    error_type: error.constructor.name,\n                    post_number: item.json?.post_number || 'unknown',\n                    ready_to_save: false\n                }\n            });\n        }\n    });\n    \n    return results;\n}\n\n// Execute and return results\ntry {\n    const results = processBlogPosts();\n    return results;\n} catch (error) {\n    return [{\n        json: {\n            error: error.message,\n            error_type: error.constructor.name,\n            error_stack: error.stack\n        }\n    }];\n}"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1024,
        48
      ],
      "id": "4f0f5237-191c-470a-85d5-90d71f63e262",
      "name": "HTML Wrap"
    },
    {
      "parameters": {
        "jsCode": "// Get the data from the previous node\nconst items = $input.all();\n\n// Process each item and create HTML files\nconst outputItems = items.map((item, index) => {\n  const data = item.json;\n  \n  // Extract the HTML content from full_html_document\n  const htmlContent = data.full_html_document;\n  \n  // Create a proper filename from the html_filename\n  const filename = data.html_filename || `post-${data.post_number || index}.html`;\n  \n  // Prepare the binary data for the HTML file\n  const binaryData = {\n    data: Buffer.from(htmlContent, 'utf-8').toString('base64'),\n    mimeType: 'text/html',\n    fileName: filename,\n    fileExtension: 'html'\n  };\n  \n  return {\n    json: {\n      post_number: data.post_number,\n      title: data.title,\n      filename: filename,\n      file_size_bytes: data.file_size_bytes,\n      success: true\n    },\n    binary: {\n      data: binaryData\n    }\n  };\n});\n\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1296,
        352
      ],
      "id": "ebb3cf0b-3272-42cc-a878-affab66d8650",
      "name": "HTML File"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "\"\"\"\nn8n Code Node: Summarize Blog Post Textual Content\nMode: Run Once for All Items\nLanguage: Python\n\nThis script extracts all textual fields from blog posts (excluding code_snippets)\nand creates concise summaries for each post.\n\nTextual fields included:\n- title\n- post_content\n- solution_steps\n- security_pitfalls\n\nExcluded:\n- code_snippets\n\"\"\"\n\nimport re\n\n\ndef extract_textual_content(blog_post):\n    \"\"\"\n    Extract all textual content from a blog post, excluding code_snippets.\n    \n    Args:\n        blog_post: Dictionary containing blog post data\n        \n    Returns:\n        Combined text string with all textual content\n    \"\"\"\n    textual_parts = []\n    \n    # Extract title\n    title = blog_post.get(\"title\", \"\")\n    if title:\n        textual_parts.append(f\"Title: {title}\")\n    \n    # Extract post content\n    post_content = blog_post.get(\"post_content\", \"\")\n    if post_content:\n        textual_parts.append(f\"\\nContent:\\n{post_content}\")\n    \n    # Extract solution steps\n    solution_steps = blog_post.get(\"solution_steps\", \"\")\n    if solution_steps:\n        textual_parts.append(f\"\\nSolution Steps:\\n{solution_steps}\")\n    \n    # Extract security pitfalls\n    security_pitfalls = blog_post.get(\"security_pitfalls\", \"\")\n    if security_pitfalls:\n        textual_parts.append(f\"\\nSecurity Pitfalls:\\n{security_pitfalls}\")\n    \n    return \"\\n\".join(textual_parts).strip()\n\n\ndef simple_summarize(text, max_length=500, max_sentences=5):\n    \"\"\"\n    Simple text summarization by extracting key sentences.\n    \n    Args:\n        text: Text to summarize\n        max_length: Maximum character length of summary\n        max_sentences: Maximum number of sentences to include\n        \n    Returns:\n        Summarized text\n    \"\"\"\n    if not text or not text.strip():\n        return \"\"\n    \n    # Split into sentences (simple approach: split on period, exclamation, question mark)\n    sentences = re.split(r'[.!?]\\s+', text)\n    sentences = [s.strip() + '.' for s in sentences if s.strip()]\n    \n    # Filter out very short sentences (likely incomplete)\n    sentences = [s for s in sentences if len(s) > 20]\n    \n    if not sentences:\n        # Fallback: return first N characters\n        return text[:max_length] + \"...\" if len(text) > max_length else text\n    \n    # Take first N sentences that fit within max_length\n    summary_parts = []\n    current_length = 0\n    \n    for sentence in sentences[:max_sentences]:\n        if current_length + len(sentence) <= max_length:\n            summary_parts.append(sentence)\n            current_length += len(sentence) + 1  # +1 for space\n        else:\n            break\n    \n    summary = \" \".join(summary_parts)\n    \n    # If summary is still too long, truncate\n    if len(summary) > max_length:\n        summary = summary[:max_length].rsplit(' ', 1)[0] + \"...\"\n    \n    return summary\n\n\ndef summarize_with_llm(text, api_key=None, model=\"gpt-3.5-turbo\", max_tokens=200):\n    \"\"\"\n    Summarize text using an LLM API (OpenAI-compatible).\n    \n    NOTE: This requires an API key and network access.\n    For n8n, you might want to use an HTTP Request node instead.\n    \n    Args:\n        text: Text to summarize\n        api_key: API key for the LLM service\n        model: Model name to use\n        max_tokens: Maximum tokens in summary\n        \n    Returns:\n        Summarized text\n    \"\"\"\n    try:\n        import requests\n        \n        if not api_key:\n            return None  # Fall back to simple summarization\n        \n        # OpenAI-compatible API call\n        url = \"https://api.openai.com/v1/chat/completions\"\n        headers = {\n            \"Authorization\": f\"Bearer {api_key}\",\n            \"Content-Type\": \"application/json\"\n        }\n        data = {\n            \"model\": model,\n            \"messages\": [\n                {\n                    \"role\": \"system\",\n                    \"content\": \"You are a helpful assistant that creates concise summaries of technical blog posts.\"\n                },\n                {\n                    \"role\": \"user\",\n                    \"content\": f\"Summarize the following blog post content in 2-3 sentences:\\n\\n{text}\"\n                }\n            ],\n            \"max_tokens\": max_tokens,\n            \"temperature\": 0.3\n        }\n        \n        response = requests.post(url, json=data, headers=headers, timeout=30)\n        \n        if response.status_code == 200:\n            result = response.json()\n            summary = result.get(\"choices\", [{}])[0].get(\"message\", {}).get(\"content\", \"\")\n            return summary.strip()\n        else:\n            return None  # Fall back to simple summarization\n            \n    except Exception as e:\n        # If LLM summarization fails, fall back to simple method\n        return None\n\n\n# ===== n8n EXECUTION =====\ntry:\n    # Access input items\n    input_items = _input.all()\n    \n    if not input_items or len(input_items) == 0:\n        raise ValueError(\"No input items found\")\n    \n    # Process all items\n    results = []\n    \n    for index, input_item in enumerate(input_items):\n        try:\n            item = input_item.json\n            \n            # Extract post number and index\n            post_number = item.get(\"post_number\", index + 1)  # Use index+1 as fallback if post_number not found\n            \n            # Extract all textual content (excluding code_snippets)\n            textual_content = extract_textual_content(item)\n            \n            # Summarize the textual content\n            # Option 1: Simple summarization (always works)\n            summary = simple_summarize(textual_content, max_length=500, max_sentences=5)\n            \n            # Option 2: LLM-based summarization (uncomment and configure if you have API access)\n            # api_key = item.get(\"openai_api_key\") or os.environ.get(\"OPENAI_API_KEY\")\n            # llm_summary = summarize_with_llm(textual_content, api_key=api_key)\n            # if llm_summary:\n            #     summary = llm_summary\n            \n            # Include summary, code_snippets, and post_number in output\n            results.append({\n                \"json\": {\n                    \"post_number\": post_number,\n                    \"textual_summary\": summary,\n                    \"code_snippets\": item.get(\"code_snippets\", \"\")\n                }\n            })\n            \n        except Exception as item_error:\n            # If processing one item fails, still try to return code_snippets\n            code_snippets = \"\"\n            post_number = index + 1\n            try:\n                if hasattr(input_item, 'json'):\n                    item = input_item.json\n                    code_snippets = item.get(\"code_snippets\", \"\")\n                    post_number = item.get(\"post_number\", index + 1)\n            except:\n                pass\n            \n            results.append({\n                \"json\": {\n                    \"post_number\": post_number,\n                    \"textual_summary\": None,\n                    \"code_snippets\": code_snippets,\n                    \"error\": str(item_error),\n                    \"error_type\": type(item_error).__name__\n                }\n            })\n    \n    # Return list of results (for \"Run Once for All Items\" mode)\n    return results\n    \nexcept Exception as e:\n    import traceback\n    error_trace = traceback.format_exc()\n    \n    # Try to get code_snippets and post_number even if there's an error\n    code_snippets = \"\"\n    post_number = 1\n    try:\n        input_items = _input.all()\n        if input_items and len(input_items) > 0:\n            item = input_items[0].json\n            code_snippets = item.get(\"code_snippets\", \"\")\n            post_number = item.get(\"post_number\", 1)\n    except:\n        pass\n    \n    return [{\n        \"json\": {\n            \"post_number\": post_number,\n            \"textual_summary\": None,\n            \"code_snippets\": code_snippets,\n            \"error\": str(e),\n            \"error_type\": type(e).__name__\n        }\n    }]"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1328,
        -192
      ],
      "id": "cffc9582-cce1-4132-a4ff-d7d83885f621",
      "name": "Summarize"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Summary HTML File with Image Generation\n *\n * Mode: Run Once for All Items\n * Language: JavaScript\n *\n * This node:\n * 1. Generates summary HTML files (existing functionality)\n * 2. Generates slide-style HTML images using the template\n *\n * Input from \"Summarize\" node:\n * - post_number\n * - textual_summary (contains title and content)\n * - code_snippets\n */\n// Get all input items\nconst items = $input.all();\n// Process each item\nconst outputItems = items.map((item, index) => {\n  const data = item.json;\n \n  // ============================================\n  // PART 1: Extract data from textual_summary\n  // ============================================\n  const textualSummary = data.textual_summary || '';\n  const codeSnippets = data.code_snippets || '';\n  const postNumber = data.post_number || index + 1;\n \n  // Extract title from textual_summary (first line after \"Title: \")\n  let title = '';\n  let content = '';\n \n  if (textualSummary) {\n    const lines = textualSummary.split('\\n');\n    const titleLine = lines.find(line => line.trim().startsWith('Title:'));\n    if (titleLine) {\n      title = titleLine.replace(/^Title:\\s*/i, '').trim();\n      // Get content after title\n      const titleIndex = lines.indexOf(titleLine);\n      content = lines.slice(titleIndex + 1).join('\\n').trim();\n    } else {\n      // Fallback: use first line as title\n      title = lines[0] || 'Untitled Post';\n      content = lines.slice(1).join('\\n').trim();\n    }\n  }\n \n  // If no title found, use default\n  if (!title) {\n    title = `Post ${postNumber}`;\n  }\n \n  // Remove headings from content (like \"Content:\", \"Introduction:\", etc.)\n  function removeHeadings(text) {\n    if (!text) return '';\n    // Remove common heading patterns\n    return text\n      .replace(/^(Content|Introduction|Summary|Overview|Description):\\s*/gmi, '')\n      .replace(/^#{1,6}\\s+.+$/gm, '') // Remove markdown headings\n      .replace(/^[A-Z][A-Z\\s]+:\\s*/gm, '') // Remove ALL CAPS headings\n      .trim();\n  }\n \n  content = removeHeadings(content);\n \n  // ============================================\n  // PART 2: Generate Summary HTML File (NO CODE SNIPPETS)\n  // ============================================\n \n  // Generate summary HTML content with ProgrammX theme (code snippets excluded, no post number)\n  let summaryHtmlContent = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"UTF-8\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n<meta name=\"description\" content=\"${escapeHtml(title)}\">\n<title>${escapeHtml(title)}</title>\n<style>\n/* Blog Post HTML Styles - ProgrammX Theme */\n* {\n    box-sizing: border-box;\n}\nbody {\n    margin: 0;\n    padding: 0;\n    background: #0F1419;\n    font-family: Arial, Helvetica, sans-serif;\n    color: #FFFFFF;\n}\n.blog-post {\n    max-width: 900px;\n    margin: 0 auto;\n    padding: 60px 40px;\n    line-height: 1.8;\n    background: #0F1419;\n    min-height: 100vh;\n}\n.blog-header {\n    display: flex;\n    align-items: center;\n    gap: 20px;\n    margin-bottom: 40px;\n    padding-bottom: 20px;\n    border-bottom: 2px solid #00CED1;\n}\n.logo {\n    width: 60px;\n    height: 60px;\n}\n.company-info {\n    display: flex;\n    flex-direction: column;\n    gap: 0px;\n}\n.company-name {\n    color: #FFFFFF;\n    font-size: 28px;\n    font-weight: bold;\n    letter-spacing: 2px;\n}\n.tagline {\n    color: #FFFFFF;\n    font-size: 16px;\n    font-weight: 400;\n    letter-spacing: 1px;\n}\n.post-title {\n    font-size: 42px;\n    font-weight: 700;\n    color: #FFFFFF;\n    margin: 0 0 40px 0;\n    line-height: 1.3;\n    letter-spacing: 1px;\n}\n.post-content {\n    margin-bottom: 40px;\n}\n.post-content p {\n    margin-bottom: 25px;\n    font-size: 18px;\n    color: #FFFFFF;\n    line-height: 1.8;\n}\n@media (max-width: 768px) {\n    .blog-post {\n        padding: 40px 20px;\n    }\n    .post-title {\n        font-size: 32px;\n    }\n    .company-name {\n        font-size: 24px;\n    }\n    .tagline {\n        font-size: 14px;\n    }\n}\n</style>\n</head>\n<body>\n<article class=\"blog-post\">\n  <div class=\"blog-header\">\n    <img class=\"logo\" src=\"https://media.licdn.com/dms/image/v2/D4D0BAQFdJWk29TWi5w/company-logo_200_200/company-logo_200_200/0/1732531337286/programm_x_logo?e=1768435200&v=beta&t=6asupSc-rvHpcrqcodceoCMGCBMKkVfcBFCIPuRottc\" alt=\"ProgrammX Logo\">\n    <div class=\"company-info\">\n      <div class=\"company-name\">ProgrammX</div>\n      <div class=\"tagline\">Transforming Ideas into Reality</div>\n    </div>\n  </div>\n \n  <h1 class=\"post-title\">${escapeHtml(title)}</h1>\n  <div class=\"post-content\">\n    <p>${escapeHtml(content)}</p>\n  </div>\n</article>\n</body>\n</html>`;\n \n  // Create summary filename\n  const postFilename = `post-${postNumber}-${sanitizeFilename(title)}.html`;\n \n  // ============================================\n  // PART 3: Generate Slide Image HTML\n  // ============================================\n \n  // Extract header text (5-6 words, ALL CAPS)\n  function extractHeader(titleText) {\n    return titleText\n      .replace(/[^a-zA-Z0-9\\s]/g, '')\n      .split(' ')\n      .filter(w => w.length > 2)\n      .slice(0, 6)\n      .join(' ')\n      .toUpperCase();\n  }\n \n  // Extract body text from content (full content now)\n  function extractBodyText(contentText) {\n    if (!contentText) return 'Key insights and information about the topic.';\n    return contentText;\n  }\n \n  const headerText = extractHeader(title);\n  const bodyText = extractBodyText(content);\n \n  // Generate slide HTML matching the exact template provided\n  const slideHtml = `<!DOCTYPE html>\n<html>\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n    }\n   \n    body {\n      width: 1024px;\n      height: 1024px;\n      background-color: #0F1419;\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Helvetica Neue', Arial, sans-serif;\n      display: flex;\n      flex-direction: column;\n      align-items: center;\n      justify-content: center;\n      position: relative;\n      overflow: hidden;\n    }\n   \n    /* Logo at Top Center */\n    .logo-section {\n      position: absolute;\n      top: 60px;\n      left: 50%;\n      transform: translateX(-50%);\n      display: flex;\n      align-items: center;\n      gap: 15px;\n      z-index: 10;\n    }\n   \n    .logo {\n      width: 70px;\n      height: 70px;\n    }\n   \n    .company-info {\n      display: flex;\n      flex-direction: column;\n      gap: 0px;\n    }\n   \n    .company-name {\n      color: #FFFFFF;\n      font-size: 32px;\n      font-weight: bold;\n      letter-spacing: 1px;\n      font-family: Arial, sans-serif;\n    }\n   \n    .tagline {\n      color: #FFFFFF;\n      font-size: 16px;\n      font-weight: 400;\n      letter-spacing: 1px;\n    }\n   \n    /* Quick Insight Card - Centered */\n    .insight-card {\n      width: 750px;\n      max-width: 85%;\n      background-color: #1A1A2E;\n      border: 2px solid #00CED1;\n      border-radius: 12px;\n      overflow: visible;\n      display: flex;\n      flex-direction: column;\n      margin-top: 120px;\n      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);\n    }\n   \n    /* Bright Teal Header Strip */\n    .header-strip {\n      background-color: #00CED1;\n      padding: 20px 50px 20px 30px;\n      width: fit-content;\n      transform: rotate(-5deg);\n      position: relative;\n      left: -50px;\n      top: -30px;\n      z-index: 1;\n      border-radius: 0 12px 12px 0;\n    }\n   \n    .header-text {\n      color: #FFFFFF;\n      font-size: 26px;\n      font-weight: 700;\n      text-transform: uppercase;\n      letter-spacing: 3px;\n      text-align: left;\n      line-height: 1.2;\n      font-family: Arial, Helvetica, sans-serif;\n    }\n   \n    /* Body Content - Darker Teal Background */\n    .card-body {\n      padding: 65px 30px 35px 30px;\n      background-color: #1A1A2E;\n    }\n   \n    .body-text {\n      color: #FFFFFF;\n      font-size: 19px;\n      line-height: 1.6;\n      text-align: left;\n      font-weight: 400;\n      font-family: Arial, Helvetica, sans-serif;\n      white-space: pre-line;\n    }\n   \n    .body-text strong {\n      font-weight: 700;\n      color: #FFFFFF;\n    }\n   \n    /* Responsive adjustments */\n    @media (max-width: 1024px) {\n      .insight-card {\n        width: 90%;\n        max-width: 700px;\n      }\n     \n      .header-text {\n        font-size: 22px;\n        letter-spacing: 2px;\n      }\n     \n      .body-text {\n        font-size: 17px;\n      }\n     \n      .card-body {\n        padding: 60px 25px 30px 25px;\n      }\n     \n      .logo-section {\n        top: 40px;\n      }\n     \n      .company-name {\n        font-size: 28px;\n      }\n    }\n  </style>\n</head>\n<body>\n  <!-- Logo at Top Center -->\n  <div class=\"logo-section\">\n    <img class=\"logo\" src=\"https://media.licdn.com/dms/image/v2/D4D0BAQFdJWk29TWi5w/company-logo_200_200/company-logo_200_200/0/1732531337286/programm_x_logo?e=1768435200&v=beta&t=6asupSc-rvHpcrqcodceoCMGCBMKkVfcBFCIPuRottc\" alt=\"ProgrammX Logo\">\n    <div class=\"company-info\">\n      <div class=\"company-name\">ProgrammX</div>\n      <div class=\"tagline\">Transforming Ideas into Reality</div>\n    </div>\n  </div>\n \n  <!-- Quick Insight Card -->\n  <div class=\"insight-card\">\n    <div class=\"header-strip\">\n      <div class=\"header-text\">QUICK INSIGHT</div>\n    </div>\n    <div class=\"card-body\">\n      <div class=\"body-text\">${escapeHtml(bodyText)}</div>\n    </div>\n  </div>\n</body>\n</html>`;\n \n  const quickInsightFilename = `quick-insight-${postNumber}.html`;\n \n  // ============================================\n  // PART 5: Prepare Binary Outputs\n  // ============================================\n \n  const postBinary = {\n    data: Buffer.from(summaryHtmlContent, 'utf-8').toString('base64'),\n    mimeType: 'text/html',\n    fileName: postFilename,\n    fileExtension: 'html'\n  };\n \n  const quickInsightBinary = {\n    data: Buffer.from(slideHtml, 'utf-8').toString('base64'),\n    mimeType: 'text/html',\n    fileName: quickInsightFilename,\n    fileExtension: 'html'\n  };\n \n  // ============================================\n  // PART 6: Return Output\n  // ============================================\n \n  return {\n    json: {\n      post_number: postNumber,\n      title: title,\n      post_filename: postFilename,\n      quick_insight_filename: quickInsightFilename,\n      post_size: Buffer.from(summaryHtmlContent, 'utf-8').length,\n      quick_insight_size: Buffer.from(slideHtml, 'utf-8').length,\n      success: true\n    },\n    binary: {\n      post: postBinary,\n      quick_insight: quickInsightBinary\n    }\n  };\n});\n// Helper functions\nfunction escapeHtml(text) {\n  if (!text) return '';\n  const map = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#039;'\n  };\n  return String(text).replace(/[&<>\"']/g, m => map[m]);\n}\nfunction sanitizeFilename(text) {\n  if (!text) return 'untitled';\n  return text\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n    .substring(0, 50);\n}\nreturn outputItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1632,
        -464
      ],
      "id": "83108e8a-b7d9-44d7-9e53-c0630456ec56",
      "name": "Summary HTML File"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nfor (const item of $input.all()) {\n  item.json.myNewField = 1;\n}\n\nreturn $input.all();"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1648,
        -192
      ],
      "id": "9f82d113-6feb-4eb4-bec8-ccb860d1e58d",
      "name": "Extract Code"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://hcti.io/v1/image",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "html",
              "value": "=={{ $json.html_with_border }}"
            },
            {
              "name": "width",
              "value": "=={{ $json.image_width }}"
            },
            {
              "name": "height",
              "value": "=={{ $json.image_height }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2960,
        -848
      ],
      "id": "ad623d2c-5880-4cd2-afcf-4f605fd2d493",
      "name": "Post -> Image",
      "credentials": {
        "httpBasicAuth": {
          "id": "ze7X1gRUMKfuDr0R",
          "name": "Page To Image"
        },
        "httpHeaderAuth": {
          "id": "7sLqtFVXloYJYPr5",
          "name": "Page To Image"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Prepare HTML for Image Conversion API\n * \n * Mode: Run Once for All Items\n * Language: JavaScript\n * \n * This code prepares HTML content for conversion to images using an external API.\n * Since n8n web doesn't allow installing Python packages, we use an API service.\n * \n * Options:\n * 1. HTML/CSS to Image API (htmlcsstoimage.com) - Free tier available\n * 2. ScreenshotAPI.net - Paid service\n * 3. ApiFlash - Paid service\n * \n * This script prepares the data for the HTTP Request node.\n * \n * IMPORTANT: This node processes ALL items and returns an array.\n */\n\n// Get ALL input items\nconst inputItems = $input.all();\n\n// Process each item\nconst results = [];\n\ninputItems.forEach((item, index) => {\n    try {\n        const json = item.json;\n        \n        // Try to get HTML content from binary data\n        let postHtml = null;\n        let quickInsightHtml = null;\n        \n        // Access binary data - try multiple methods\n        try {\n            // Debug: Log available binary keys\n            if (item.binary) {\n                const binaryKeys = Object.keys(item.binary);\n                console.log(`Item ${index + 1} binary keys:`, binaryKeys);\n            } else {\n                console.log(`Item ${index + 1}: No binary data found`);\n            }\n            \n            if (item.binary) {\n                // Helper function to extract HTML from binary data\n                const extractHtmlFromBinary = (binaryData) => {\n                    if (!binaryData) return null;\n                    \n                    // Method 1: Standard structure { data: base64String, ... }\n                    if (binaryData.data) {\n                        if (typeof binaryData.data === 'string') {\n                            try {\n                                return Buffer.from(binaryData.data, 'base64').toString('utf-8');\n                            } catch (e) {\n                                // If base64 decode fails, try as plain string\n                                return binaryData.data;\n                            }\n                        } else if (Buffer.isBuffer(binaryData.data)) {\n                            return binaryData.data.toString('utf-8');\n                        }\n                    }\n                    \n                    // Method 2: Direct base64 string\n                    if (typeof binaryData === 'string') {\n                        try {\n                            return Buffer.from(binaryData, 'base64').toString('utf-8');\n                        } catch (e) {\n                            return binaryData;\n                        }\n                    }\n                    \n                    // Method 3: Try accessing as object with different properties\n                    if (typeof binaryData === 'object') {\n                        // Try common property names\n                        const possibleDataProps = ['content', 'body', 'html', 'text', 'value'];\n                        for (const prop of possibleDataProps) {\n                            if (binaryData[prop]) {\n                                if (typeof binaryData[prop] === 'string') {\n                                    try {\n                                        return Buffer.from(binaryData[prop], 'base64').toString('utf-8');\n                                    } catch (e) {\n                                        return binaryData[prop];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    \n                    return null;\n                };\n                \n                // Try multiple binary key names (summary, post, etc.)\n                const possibleSummaryKeys = ['summary', 'post', 'post_html', 'html'];\n                for (const key of possibleSummaryKeys) {\n                    if (item.binary[key] && !postHtml) {\n                        postHtml = extractHtmlFromBinary(item.binary[key]);\n                        if (postHtml) {\n                            console.log(`Item ${index + 1}: Found post HTML in binary.${key}`);\n                            break;\n                        }\n                    }\n                }\n                \n                // Try multiple binary key names (slide, quick_insight, etc.)\n                const possibleSlideKeys = ['slide', 'quick_insight', 'quick_insight_html', 'insight'];\n                for (const key of possibleSlideKeys) {\n                    if (item.binary[key] && !quickInsightHtml) {\n                        quickInsightHtml = extractHtmlFromBinary(item.binary[key]);\n                        if (quickInsightHtml) {\n                            console.log(`Item ${index + 1}: Found quick insight HTML in binary.${key}`);\n                            break;\n                        }\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(`Error accessing binary data for item ${index + 1}:`, error);\n            console.error(`Error details:`, error.stack);\n        }\n        \n        // Get post number\n        const postNumber = json.post_number || (index + 1);\n        \n        // Get filenames from JSON or generate defaults\n        const postFilename = json.summary_filename || json.post_filename || `post-${postNumber}.html`;\n        const quickInsightFilename = json.slide_filename || json.quick_insight_filename || `quick-insight-${postNumber}.html`;\n        \n        // Prepare Microlink.io URL for post HTML\n        let microlinkUrl = null;\n        let encodedHtml = null;\n        \n        if (postHtml) {\n            // URL encode the HTML for Microlink\n            encodedHtml = encodeURIComponent(postHtml);\n            // Create data URL for Microlink\n            microlinkUrl = `data:text/html,${encodedHtml}`;\n        }\n        \n        // Prepare Microlink.io URL for quick insight HTML (optional)\n        let quickInsightMicrolinkUrl = null;\n        let quickInsightEncodedHtml = null;\n        \n        if (quickInsightHtml) {\n            quickInsightEncodedHtml = encodeURIComponent(quickInsightHtml);\n            quickInsightMicrolinkUrl = `data:text/html,${quickInsightEncodedHtml}`;\n        }\n        \n        // Debug info\n        const debugInfo = {\n            binary_keys_available: item.binary ? Object.keys(item.binary) : [],\n            post_html_length: postHtml ? postHtml.length : 0,\n            quick_insight_html_length: quickInsightHtml ? quickInsightHtml.length : 0\n        };\n        \n        // Return data for API conversion\n        // IMPORTANT: Preserve binary data for next nodes\n        const outputItem = {\n            json: {\n                post_number: postNumber,\n                title: json.title || `Post ${postNumber}`,\n                post_filename: postFilename,\n                quick_insight_filename: quickInsightFilename,\n                image_filename: postFilename.replace('.html', '.png'),\n                quick_insight_image_filename: quickInsightFilename.replace('.html', '.png'),\n                \n                // HTML content (for reference)\n                post_html: postHtml,\n                quick_insight_html: quickInsightHtml,\n                \n                // Encoded HTML (for reference)\n                encoded_html: encodedHtml,\n                quick_insight_encoded_html: quickInsightEncodedHtml,\n                \n                // Microlink URLs (REQUIRED for HTTP Request node)\n                microlink_url: microlinkUrl,\n                quick_insight_microlink_url: quickInsightMicrolinkUrl,\n                \n                // Flags to check if HTML was found\n                has_post_html: !!postHtml,\n                has_quick_insight_html: !!quickInsightHtml,\n                \n                // Debug info (remove this after fixing)\n                _debug: debugInfo,\n                \n                // Original data\n                ...json\n            }\n        };\n        \n        // Preserve binary data if it exists\n        if (item.binary) {\n            outputItem.binary = item.binary;\n        }\n        \n        results.push(outputItem);\n        \n    } catch (error) {\n        // If processing fails for an item, still return it with error info\n        const postNumber = (item.json && item.json.post_number) || (index + 1);\n        results.push({\n            json: {\n                post_number: postNumber,\n                post_filename: `post-${postNumber}.html`,\n                quick_insight_filename: `quick-insight-${postNumber}.html`,\n                post_html: null,\n                quick_insight_html: null,\n                has_post_html: false,\n                has_quick_insight_html: false,\n                error: error.message,\n                error_type: error.constructor.name,\n                ...(item.json || {})\n            }\n        });\n    }\n});\n\n// Return all processed items\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2352,
        -1008
      ],
      "id": "565a9067-73c3-4e88-8f74-93e9e1f634e7",
      "name": "MicroLink"
    },
    {
      "parameters": {
        "url": "={{ $json.url }}",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBasicAuth",
        "options": {
          "response": {
            "response": {
              "responseFormat": "file"
            }
          }
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        3312,
        -848
      ],
      "id": "dcb5eece-96a2-4fc1-a7d6-31f02552e272",
      "name": "Download Image",
      "credentials": {
        "httpBasicAuth": {
          "id": "ze7X1gRUMKfuDr0R",
          "name": "Page To Image"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Split Post and Quick Insight Items\n * \n * Mode: Run Once for All Items\n * Language: JavaScript\n * \n * This node splits each input item into 2 items:\n * 1. One item for Post HTML (binary.post or binary.summary)\n * 2. One item for Quick Insight HTML (binary.quick_insight or binary.slide)\n * \n * This allows the workflow to process both types of images separately.\n */\n\n// Get ALL input items\nconst inputItems = $input.all();\n\n// Process each item and split into post and quick insight\nconst results = [];\n\ninputItems.forEach((item, index) => {\n    try {\n        const json = item.json;\n        const postNumber = json.post_number || (index + 1);\n        \n        // Helper function to extract HTML from binary data\n        const extractHtmlFromBinary = (binaryData) => {\n            if (!binaryData) return null;\n            \n            // Method 1: Standard structure { data: base64String, ... }\n            if (binaryData.data) {\n                if (typeof binaryData.data === 'string') {\n                    try {\n                        return Buffer.from(binaryData.data, 'base64').toString('utf-8');\n                    } catch (e) {\n                        return binaryData.data;\n                    }\n                } else if (Buffer.isBuffer(binaryData.data)) {\n                    return binaryData.data.toString('utf-8');\n                }\n            }\n            \n            // Method 2: Direct base64 string\n            if (typeof binaryData === 'string') {\n                try {\n                    return Buffer.from(binaryData, 'base64').toString('utf-8');\n                } catch (e) {\n                    return binaryData;\n                }\n            }\n            \n            return null;\n        };\n        \n        // Try to find post HTML from binary\n        let postHtml = null;\n        let postBinaryKey = null;\n        const postBinaryKeys = ['post', 'summary', 'post_html', 'html'];\n        \n        for (const key of postBinaryKeys) {\n            if (item.binary && item.binary[key]) {\n                postHtml = extractHtmlFromBinary(item.binary[key]);\n                if (postHtml) {\n                    postBinaryKey = key;\n                    break;\n                }\n            }\n        }\n        \n        // Try to find quick insight HTML from binary\n        let quickInsightHtml = null;\n        let quickInsightBinaryKey = null;\n        const quickInsightBinaryKeys = ['quick_insight', 'slide', 'quick_insight_html', 'insight'];\n        \n        for (const key of quickInsightBinaryKeys) {\n            if (item.binary && item.binary[key]) {\n                quickInsightHtml = extractHtmlFromBinary(item.binary[key]);\n                if (quickInsightHtml) {\n                    quickInsightBinaryKey = key;\n                    break;\n                }\n            }\n        }\n        \n        // Create item for POST HTML\n        if (postHtml) {\n            const postItem = {\n                json: {\n                    ...json,\n                    item_type: 'post',\n                    html: postHtml,\n                    html_source: postBinaryKey,\n                    image_filename: (json.post_filename || json.summary_filename || `post-${postNumber}.html`).replace('.html', '.png'),\n                    original_post_number: postNumber\n                }\n            };\n            \n            // Preserve binary data if needed\n            if (item.binary) {\n                postItem.binary = {};\n                // Keep only the post binary\n                if (item.binary[postBinaryKey]) {\n                    postItem.binary[postBinaryKey] = item.binary[postBinaryKey];\n                }\n            }\n            \n            results.push(postItem);\n        }\n        \n        // Create item for QUICK INSIGHT HTML\n        if (quickInsightHtml) {\n            const quickInsightItem = {\n                json: {\n                    ...json,\n                    item_type: 'quick_insight',\n                    html: quickInsightHtml,\n                    html_source: quickInsightBinaryKey,\n                    image_filename: (json.quick_insight_filename || json.slide_filename || `quick-insight-${postNumber}.html`).replace('.html', '.png'),\n                    original_post_number: postNumber\n                }\n            };\n            \n            // Preserve binary data if needed\n            if (item.binary) {\n                quickInsightItem.binary = {};\n                // Keep only the quick insight binary\n                if (item.binary[quickInsightBinaryKey]) {\n                    quickInsightItem.binary[quickInsightBinaryKey] = item.binary[quickInsightBinaryKey];\n                }\n            }\n            \n            results.push(quickInsightItem);\n        }\n        \n        // If neither HTML found, still create an item with error info\n        if (!postHtml && !quickInsightHtml) {\n            results.push({\n                json: {\n                    ...json,\n                    item_type: 'error',\n                    html: null,\n                    error: 'No HTML content found in binary data',\n                    available_binary_keys: item.binary ? Object.keys(item.binary) : [],\n                    original_post_number: postNumber\n                }\n            });\n        }\n        \n    } catch (error) {\n        // If processing fails, still return error item\n        const postNumber = (item.json && item.json.post_number) || (index + 1);\n        results.push({\n            json: {\n                ...(item.json || {}),\n                item_type: 'error',\n                html: null,\n                error: error.message,\n                error_type: error.constructor.name,\n                original_post_number: postNumber\n            }\n        });\n    }\n});\n\n// Return all split items\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1840,
        -464
      ],
      "id": "54b16ebc-1ff5-494c-a3f6-c99db37657c0",
      "name": "Split Post and Insight"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Add Border and Configure Size for HTML Images\n * \n * Mode: Run Once for All Items\n * Language: JavaScript\n * \n * This node:\n * 1. Wraps HTML content with border styling\n * 2. Configures image dimensions (width/height)\n * 3. Prepares HTML for image conversion API\n * \n * Place this node AFTER \"Split Post and Quick Insight\" and BEFORE \"Post -> Image\"\n */\n\n// ============================================\n// CONFIGURATION - Customize these values\n// ============================================\n\n// Image dimensions (in pixels)\nconst IMAGE_WIDTH = 1200;  // Change this to your desired width\nconst IMAGE_HEIGHT = 1600; // Change this to your desired height\n\n// Border configuration\nconst BORDER_WIDTH = 8;           // Border thickness in pixels\nconst BORDER_COLOR = '#0DB2B6';   // Border color (ProgrammX theme teal)\nconst BORDER_STYLE = 'solid';     // Border style: solid, dashed, dotted, double\nconst BORDER_RADIUS = 16;         // Rounded border radius in pixels\n\n// Background color (optional - for padding around content)\nconst BACKGROUND_COLOR = '#ffffff'; // White background\n\n// ============================================\n// END CONFIGURATION\n// ============================================\n\n// Get ALL input items\nconst inputItems = $input.all();\n\n// Process each item\nconst results = [];\n\ninputItems.forEach((item, index) => {\n    try {\n        const json = item.json;\n        \n        // Get HTML content\n        let html = json.html || json.post_html || json.quick_insight_html;\n        \n        if (!html) {\n            // If no HTML in JSON, try to extract from binary\n            if (item.binary) {\n                const extractHtmlFromBinary = (binaryData) => {\n                    if (!binaryData) return null;\n                    if (binaryData.data) {\n                        if (typeof binaryData.data === 'string') {\n                            try {\n                                return Buffer.from(binaryData.data, 'base64').toString('utf-8');\n                            } catch (e) {\n                                return binaryData.data;\n                            }\n                        } else if (Buffer.isBuffer(binaryData.data)) {\n                            return binaryData.data.toString('utf-8');\n                        }\n                    }\n                    return null;\n                };\n                \n                // Try to find HTML in binary\n                const binaryKeys = Object.keys(item.binary);\n                for (const key of binaryKeys) {\n                    html = extractHtmlFromBinary(item.binary[key]);\n                    if (html) break;\n                }\n            }\n        }\n        \n        if (!html) {\n            // Skip items without HTML\n            results.push({\n                json: {\n                    ...json,\n                    html: null,\n                    html_with_border: null,\n                    image_width: IMAGE_WIDTH,\n                    image_height: IMAGE_HEIGHT,\n                    error: 'No HTML content found'\n                }\n            });\n            return;\n        }\n        \n        // Function to wrap HTML with border styling\n        const wrapHtmlWithBorder = (htmlContent) => {\n            // Check if HTML already has a body tag\n            const hasBodyTag = /<body[^>]*>/i.test(htmlContent);\n            const hasHtmlTag = /<html[^>]*>/i.test(htmlContent);\n            \n            // Extract existing styles from <style> tags or inline styles\n            let existingStyles = '';\n            const styleMatch = htmlContent.match(/<style[^>]*>([\\s\\S]*?)<\\/style>/i);\n            if (styleMatch) {\n                existingStyles = styleMatch[1];\n            }\n            \n            // Create border wrapper CSS\n            const borderWrapperCSS = `\n                <style>\n                    /* Border wrapper styles */\n                    .border-wrapper {\n                        width: 100%;\n                        height: 100%;\n                        box-sizing: border-box;\n                        border: ${BORDER_WIDTH}px ${BORDER_STYLE} ${BORDER_COLOR};\n                        border-radius: ${BORDER_RADIUS}px;\n                        background-color: ${BACKGROUND_COLOR};\n                        padding: 0;\n                        margin: 0;\n                        overflow: hidden;\n                    }\n                    \n                    /* Ensure body takes full space */\n                    body {\n                        margin: 0;\n                        padding: 0;\n                        width: 100%;\n                        height: 100%;\n                        box-sizing: border-box;\n                    }\n                    \n                    /* Ensure html takes full space */\n                    html {\n                        margin: 0;\n                        padding: 0;\n                        width: 100%;\n                        height: 100%;\n                        box-sizing: border-box;\n                    }\n                    \n                    /* Existing styles */\n                    ${existingStyles}\n                </style>\n            `;\n            \n            // If HTML already has structure, inject border wrapper\n            if (hasHtmlTag) {\n                // Find the body tag and wrap its content\n                if (hasBodyTag) {\n                    // Wrap body content with border div\n                    htmlContent = htmlContent.replace(\n                        /<body[^>]*>/i,\n                        `<body><div class=\"border-wrapper\">`\n                    );\n                    htmlContent = htmlContent.replace(\n                        /<\\/body>/i,\n                        `</div></body>`\n                    );\n                    \n                    // Inject CSS into head or before closing html tag\n                    if (htmlContent.includes('</head>')) {\n                        htmlContent = htmlContent.replace('</head>', `${borderWrapperCSS}</head>`);\n                    } else if (htmlContent.includes('<html')) {\n                        htmlContent = htmlContent.replace(/<html[^>]*>/i, `$&${borderWrapperCSS}`);\n                    } else {\n                        htmlContent = borderWrapperCSS + htmlContent;\n                    }\n                } else {\n                    // No body tag, wrap entire content\n                    htmlContent = htmlContent.replace(\n                        /<html[^>]*>/i,\n                        `$&${borderWrapperCSS}<body><div class=\"border-wrapper\">`\n                    );\n                    htmlContent = htmlContent.replace(\n                        /<\\/html>/i,\n                        `</div></body></html>`\n                    );\n                }\n            } else {\n                // No HTML structure, create full HTML document\n                htmlContent = `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    ${borderWrapperCSS}\n</head>\n<body>\n    <div class=\"border-wrapper\">\n        ${htmlContent}\n    </div>\n</body>\n</html>`;\n            }\n            \n            return htmlContent;\n        };\n        \n        // Wrap HTML with border\n        const htmlWithBorder = wrapHtmlWithBorder(html);\n        \n        // Determine image dimensions based on item type\n        let imageWidth = IMAGE_WIDTH;\n        let imageHeight = IMAGE_HEIGHT;\n        \n        // You can customize dimensions per item type\n        if (json.item_type === 'quick_insight') {\n            // Quick insights might be square\n            imageWidth = 1024;\n            imageHeight = 1024;\n        } else if (json.item_type === 'post') {\n            // Posts might be portrait\n            imageWidth = IMAGE_WIDTH;\n            imageHeight = IMAGE_HEIGHT;\n        }\n        \n        // Allow override from JSON if provided\n        if (json.image_width) imageWidth = parseInt(json.image_width);\n        if (json.image_height) imageHeight = parseInt(json.image_height);\n        \n        // Create output item\n        const outputItem = {\n            json: {\n                ...json,\n                html: html,                    // Original HTML\n                html_with_border: htmlWithBorder, // HTML with border\n                image_width: imageWidth,\n                image_height: imageHeight,\n                border_width: BORDER_WIDTH,\n                border_color: BORDER_COLOR,\n                border_style: BORDER_STYLE,\n                border_radius: BORDER_RADIUS,\n                background_color: BACKGROUND_COLOR\n            }\n        };\n        \n        // Preserve binary data if it exists\n        if (item.binary) {\n            outputItem.binary = item.binary;\n        }\n        \n        results.push(outputItem);\n        \n    } catch (error) {\n        // If processing fails, still return error item\n        results.push({\n            json: {\n                ...(item.json || {}),\n                html: null,\n                html_with_border: null,\n                error: error.message,\n                error_type: error.constructor.name\n            }\n        });\n    }\n});\n\n// Return all processed items\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2048,
        -464
      ],
      "id": "d56e1abd-1868-461c-8590-a7083a44a0af",
      "name": "Specify Border and Size"
    },
    {
      "parameters": {
        "batchSize": 2,
        "options": {
          "reset": false
        }
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2256,
        -464
      ],
      "id": "54fb1fc7-5ca3-41a5-b141-55f7b51feb18",
      "name": "Split Into Batches"
    },
    {
      "parameters": {
        "amount": 3
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        2512,
        -448
      ],
      "id": "e7b43616-07d7-4f41-9be0-dfdcdb55fded",
      "name": "Wait Between Batches",
      "webhookId": "495efd41-ade9-44b7-95de-9f768550105b"
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Code Node: Apply PresmaX Color Scheme to HTML\n * \n * Mode: Run Once for All Items\n * Language: JavaScript\n * \n * This code applies PresmaX dark teal color scheme to HTML content.\n * It looks for HTML in multiple possible locations (JSON fields and binary data).\n */\n\n// Get ALL input items\nconst inputItems = $input.all();\n\n// Process each item\nconst results = [];\n\ninputItems.forEach((item, index) => {\n    try {\n        const data = item.json;\n        \n        // Try to get HTML content from multiple possible sources\n        let htmlContent = null;\n        \n        // Method 1: Check JSON fields (multiple possible names)\n        const possibleJsonFields = [\n            'full_html_document',\n            'html',\n            'post_html',\n            'html_content',\n            'website_html',\n            'html_with_border',\n            'summary_html',\n            'content_html'\n        ];\n        \n        for (const field of possibleJsonFields) {\n            if (data[field] && typeof data[field] === 'string') {\n                htmlContent = data[field];\n                break;\n            }\n        }\n        \n        // Method 2: Check binary data if HTML not found in JSON\n        if (!htmlContent && item.binary) {\n            const extractHtmlFromBinary = (binaryData) => {\n                if (!binaryData) return null;\n                \n                // Standard structure { data: base64String, ... }\n                if (binaryData.data) {\n                    if (typeof binaryData.data === 'string') {\n                        try {\n                            return Buffer.from(binaryData.data, 'base64').toString('utf-8');\n                        } catch (e) {\n                            // If base64 decode fails, try as plain string\n                            return binaryData.data;\n                        }\n                    } else if (Buffer.isBuffer(binaryData.data)) {\n                        return binaryData.data.toString('utf-8');\n                    }\n                }\n                \n                // Direct base64 string\n                if (typeof binaryData === 'string') {\n                    try {\n                        return Buffer.from(binaryData, 'base64').toString('utf-8');\n                    } catch (e) {\n                        return binaryData;\n                    }\n                }\n                \n                return null;\n            };\n            \n            // Try multiple binary key names\n            const possibleBinaryKeys = [\n                'post',\n                'summary',\n                'html',\n                'post_html',\n                'html_file',\n                'website_html',\n                'data'\n            ];\n            \n            for (const key of possibleBinaryKeys) {\n                if (item.binary[key]) {\n                    htmlContent = extractHtmlFromBinary(item.binary[key]);\n                    if (htmlContent) {\n                        // Verify it's actually HTML\n                        if (htmlContent.trim().toLowerCase().startsWith('<!doctype') || \n                            htmlContent.trim().toLowerCase().startsWith('<html')) {\n                            break;\n                        } else {\n                            htmlContent = null; // Not HTML, continue searching\n                        }\n                    }\n                }\n            }\n        }\n        \n        // If still no HTML found, return error\n        if (!htmlContent) {\n            results.push({\n                json: {\n                    ...data,\n                    processed: false,\n                    error: 'No HTML content found in JSON fields or binary data',\n                    available_json_fields: Object.keys(data),\n                    available_binary_keys: item.binary ? Object.keys(item.binary) : []\n                }\n            });\n            return;\n        }\n        \n        // Apply PresmaX dark teal color scheme with ProgrammX theme color\n        const applyPresmaXColorScheme = (html) => {\n            const styleId = 'presmax-theme-override';\n            \n            // Remove existing override if present\n            html = html.replace(\n                new RegExp(`<style[\\\\s\\\\S]*?id\\\\s*=\\\\s*[\"'\\`]${styleId}[\"'\\`][\\\\s\\\\S]*?<\\\\/style>`, 'gi'),\n                ''\n            );\n            \n            // Remove post number elements from HTML - More aggressive removal\n            // Pattern 1: Standard div with post-number class\n            html = html.replace(/<div[^>]*class\\s*=\\s*[\"']post-number[\"'][^>]*>[\\s\\S]*?<\\/div>/gi, '');\n            // Pattern 2: Div with post-number in class list\n            html = html.replace(/<div[^>]*class\\s*=\\s*[\"'][^\"']*post-number[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/div>/gi, '');\n            // Pattern 3: Span elements\n            html = html.replace(/<span[^>]*class\\s*=\\s*[\"']post-number[\"'][^>]*>[\\s\\S]*?<\\/span>/gi, '');\n            html = html.replace(/<span[^>]*class\\s*=\\s*[\"'][^\"']*post-number[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/span>/gi, '');\n            // Pattern 4: Any element containing \"POST #\" or \"Post #\" text (case insensitive)\n            html = html.replace(/<[^>]+>[\\s\\S]*?POST\\s*#\\s*\\d+[\\s\\S]*?<\\/[^>]+>/gi, '');\n            html = html.replace(/<[^>]+>[\\s\\S]*?Post\\s*#\\s*\\d+[\\s\\S]*?<\\/[^>]+>/gi, '');\n            // Pattern 5: Remove any text node containing \"POST #\" or \"Post #\" (standalone)\n            html = html.replace(/(?:^|\\n)\\s*POST\\s*#\\s*\\d+\\s*(?:\\n|$)/gim, '');\n            html = html.replace(/(?:^|\\n)\\s*Post\\s*#\\s*\\d+\\s*(?:\\n|$)/gim, '');\n            // Pattern 6: Remove elements with id containing post-number\n            html = html.replace(/<[^>]+id\\s*=\\s*[\"'][^\"']*post-number[^\"']*[\"'][^>]*>[\\s\\S]*?<\\/[^>]+>/gi, '');\n            // Pattern 7: Remove any div/span that might contain post number text anywhere\n            html = html.replace(/<div[^>]*>[\\s\\S]*?POST\\s*#[\\s\\S]*?<\\/div>/gi, '');\n            html = html.replace(/<span[^>]*>[\\s\\S]*?POST\\s*#[\\s\\S]*?<\\/span>/gi, '');\n            \n            const overrideCSS = `<style id=\"${styleId}\">\n:root {\n  --presma-bg-primary: #020617;\n  --presma-bg-secondary: #0f172a;\n  --presma-bg-tertiary: #1e293b;\n  --presma-text-primary: #f8fafc;\n  --presma-text-secondary: #cbd5e1;\n  --presma-text-muted: #94a3b8;\n  --presma-accent: #0DB2B6;\n  --presma-accent-light: #22d3ee;\n  --presma-accent-dark: #00a89a;\n  --presma-border: #334155;\n  --presma-border-light: #475569;\n  --presma-code-bg: #0f172a;\n  --presma-code-text: #e2e8f0;\n}\n\nhtml, body { \n  background-color: var(--presma-bg-primary) !important; \n  color: var(--presma-text-primary) !important; \n}\n\n*, *::before, *::after { \n  border-color: var(--presma-border) !important; \n}\n\nh1, h2, h3, h4, h5, h6 { \n  color: var(--presma-text-primary) !important; \n}\n\np, li { \n  color: var(--presma-text-secondary) !important; \n}\n\na { \n  color: var(--presma-accent) !important; \n}\n\na:hover { \n  color: var(--presma-accent-light) !important; \n}\n\npre, code { \n  background-color: var(--presma-code-bg) !important; \n  color: var(--presma-code-text) !important; \n  border: 1px solid var(--presma-border-light) !important; \n}\n\nblockquote { \n  background-color: var(--presma-bg-secondary) !important; \n  border-left: 4px solid var(--presma-accent) !important; \n  color: var(--presma-text-secondary) !important; \n}\n\ntable { \n  background-color: var(--presma-bg-secondary) !important; \n}\n\nth { \n  background-color: var(--presma-bg-tertiary) !important; \n  color: var(--presma-text-primary) !important; \n}\n\nbutton, [class*=\"btn\"] { \n  background-color: var(--presma-accent) !important; \n  color: var(--presma-text-primary) !important; \n}\n\nheader, nav, footer { \n  background-color: var(--presma-bg-secondary) !important; \n}\n\n.quick-insight { \n  background: linear-gradient(135deg, var(--presma-accent), var(--presma-accent-light)) !important; \n  color: var(--presma-text-primary) !important; \n}\n\n.blog-post {\n  background-color: var(--presma-bg-primary) !important;\n  color: var(--presma-text-primary) !important;\n}\n\n.post-content {\n  color: var(--presma-text-secondary) !important;\n}\n\n.code-block-wrapper {\n  background-color: var(--presma-code-bg) !important;\n  border: 1px solid var(--presma-border-light) !important;\n}\n\n.code-header {\n  background-color: var(--presma-bg-tertiary) !important;\n  color: var(--presma-text-primary) !important;\n}\n\n/* Hide post number elements - Multiple selectors for maximum coverage */\n.post-number,\n[class*=\"post-number\"],\n[class*=\"post_number\"],\n[class*=\"postNumber\"],\n[id*=\"post-number\"],\n[id*=\"post_number\"],\n[id*=\"postNumber\"] {\n  display: none !important;\n  visibility: hidden !important;\n  height: 0 !important;\n  width: 0 !important;\n  margin: 0 !important;\n  padding: 0 !important;\n  overflow: hidden !important;\n  font-size: 0 !important;\n  line-height: 0 !important;\n  opacity: 0 !important;\n  position: absolute !important;\n  left: -9999px !important;\n  clip: rect(0, 0, 0, 0) !important;\n}\n\n/* ProgrammX theme specific colors */\n.blog-header {\n  border-bottom-color: var(--presma-accent) !important;\n}\n\n.solution-steps {\n  border-left-color: var(--presma-accent) !important;\n}\n\nblockquote {\n  border-left-color: var(--presma-accent) !important;\n}\n\n/* Ensure ProgrammX teal (#0DB2B6) is used for all accents - Direct color application */\na, \na:link,\na:visited {\n  color: #0DB2B6 !important;\n}\n\na:hover,\na:active,\na:focus {\n  color: #22d3ee !important;\n}\n\nbutton, \n[class*=\"btn\"],\n[class*=\"button\"],\ninput[type=\"button\"],\ninput[type=\"submit\"] {\n  background-color: #0DB2B6 !important;\n  color: var(--presma-text-primary) !important;\n  border-color: #0DB2B6 !important;\n}\n\nbutton:hover,\n[class*=\"btn\"]:hover,\n[class*=\"button\"]:hover {\n  background-color: #22d3ee !important;\n  border-color: #22d3ee !important;\n}\n\n.blog-header {\n  border-bottom-color: #0DB2B6 !important;\n}\n\n.solution-steps {\n  border-left-color: #0DB2B6 !important;\n  background-color: var(--presma-bg-secondary) !important;\n}\n\n.solution-steps h2 {\n  color: #0DB2B6 !important;\n}\n\nblockquote {\n  border-left-color: #0DB2B6 !important;\n  background-color: var(--presma-bg-secondary) !important;\n}\n\n.quick-insight {\n  background: linear-gradient(135deg, #0DB2B6, #22d3ee) !important;\n  color: var(--presma-text-primary) !important;\n}\n\n/* Apply ProgrammX color to all borders and accents */\n[class*=\"border\"],\n[style*=\"border\"] {\n  border-color: #0DB2B6 !important;\n}\n\n/* Code block accents */\n.code-header {\n  background-color: var(--presma-bg-tertiary) !important;\n  color: #0DB2B6 !important;\n  border-bottom-color: #0DB2B6 !important;\n}\n</style>`;\n            \n            // Add JavaScript to remove post numbers on page load (backup method)\n            const removePostNumberScript = `\n<script>\n(function() {\n    // Remove post number elements on page load\n    function removePostNumbers() {\n        // Remove by class\n        const postNumberElements = document.querySelectorAll('.post-number, [class*=\"post-number\"], [class*=\"post_number\"]');\n        postNumberElements.forEach(el => el.remove());\n        \n        // Remove by text content\n        const allElements = document.querySelectorAll('*');\n        allElements.forEach(el => {\n            const text = el.textContent || el.innerText || '';\n            if (text.match(/POST\\\\s*#\\\\s*\\\\d+/i)) {\n                // Check if it's just the post number, not part of larger content\n                if (text.trim().match(/^POST\\\\s*#\\\\s*\\\\d+$/i) || el.classList.contains('post-number')) {\n                    el.remove();\n                }\n            }\n        });\n    }\n    \n    // Run immediately\n    removePostNumbers();\n    \n    // Run after DOM is fully loaded\n    if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', removePostNumbers);\n    } else {\n        removePostNumbers();\n    }\n    \n    // Run after a short delay (in case content loads dynamically)\n    setTimeout(removePostNumbers, 100);\n    setTimeout(removePostNumbers, 500);\n})();\n</script>`;\n            \n            // Insert CSS into <head> if it exists, otherwise prepend\n            if (/<head/i.test(html)) {\n                html = html.replace(/<head\\b([^>]*)>/i, `<head$1>${overrideCSS}`);\n            } else {\n                html = overrideCSS + html;\n            }\n            \n            // Insert JavaScript before closing </body> or at end of HTML\n            if (/<\\/body>/i.test(html)) {\n                html = html.replace(/<\\/body>/i, `${removePostNumberScript}</body>`);\n            } else if (/<\\/html>/i.test(html)) {\n                html = html.replace(/<\\/html>/i, `${removePostNumberScript}</html>`);\n            } else {\n                html = html + removePostNumberScript;\n            }\n            \n            return html;\n        };\n        \n        const newHtmlContent = applyPresmaXColorScheme(htmlContent);\n        \n        // Create a proper themed filename\n        const originalFilename = data.filename || `post-${data.post_number || index + 1}.html`;\n        const filename = originalFilename.replace(/\\.html$/i, '-presmax.html');\n        \n        // Prepare the binary data for the HTML file\n        const binaryData = {\n            data: Buffer.from(newHtmlContent, 'utf-8').toString('base64'),\n            mimeType: 'text/html',\n            fileName: filename,\n            fileExtension: 'html'\n        };\n        \n        results.push({\n            json: {\n                post_number: data.post_number,\n                title: data.title,\n                filename: filename,\n                original_filename: originalFilename,\n                original_size_bytes: data.file_size_bytes || htmlContent.length,\n                new_size_bytes: newHtmlContent.length,\n                processed: true,\n                success: true,\n                html_source: htmlContent ? 'found' : 'not_found'\n            },\n            binary: {\n                data: binaryData\n            }\n        });\n        \n    } catch (error) {\n        results.push({\n            json: {\n                ...(item.json || {}),\n                processed: false,\n                error: error.message,\n                error_type: error.constructor.name,\n                error_stack: error.stack\n            }\n        });\n    }\n});\n\n// Return all processed items\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1664,
        352
      ],
      "id": "6bc9cf91-b12a-435a-af0c-46afd849207e",
      "name": "Blog Generator"
    }
  ],
  "pinData": {},
  "connections": {
    "Trigger": {
      "main": [
        [
          {
            "node": "AI Questions Fetching",
            "type": "main",
            "index": 0
          },
          {
            "node": "Blockchain Questions Fetching",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Blockchain Questions Fetching": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "AI Questions Fetching": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Flatten Array",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Flatten Array": {
      "main": [
        [
          {
            "node": "Remove Duplicates",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove Duplicates": {
      "main": [
        [
          {
            "node": "Count Questions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Filter Questions by Threshold",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Count Questions": {
      "main": [
        []
      ]
    },
    "Filter Questions by Threshold": {
      "main": [
        [
          {
            "node": "Count Filtered Questions",
            "type": "main",
            "index": 0
          },
          {
            "node": "Display Questions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Display Questions": {
      "main": [
        [
          {
            "node": "Parse Questions",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Questions": {
      "main": [
        [
          {
            "node": "Content Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "GPT 4.1 mini": {
      "ai_languageModel": [
        [
          {
            "node": "Content Generator",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Content Generator": {
      "main": [
        [
          {
            "node": "Parse Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Content": {
      "main": [
        [
          {
            "node": "Fetch Post Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Fetch Post Content": {
      "main": [
        [
          {
            "node": "Extract Content Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Content Data": {
      "main": [
        [
          {
            "node": "Clean Post Content",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Post Content": {
      "main": [
        [
          {
            "node": "Clean Code Snippets",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Code Snippets": {
      "main": [
        [
          {
            "node": "Clean Code Snippets 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Clean Code Snippets 2": {
      "main": [
        [
          {
            "node": "Post -> HTML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post -> HTML": {
      "main": [
        [
          {
            "node": "HTML Wrap",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML Wrap": {
      "main": [
        [
          {
            "node": "HTML File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Summarize",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTML File": {
      "main": [
        [
          {
            "node": "Blog Generator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summarize": {
      "main": [
        [
          {
            "node": "Summary HTML File",
            "type": "main",
            "index": 0
          },
          {
            "node": "Extract Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summary HTML File": {
      "main": [
        [
          {
            "node": "Split Post and Insight",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "MicroLink": {
      "main": [
        []
      ]
    },
    "Post -> Image": {
      "main": [
        [
          {
            "node": "Download Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Post and Insight": {
      "main": [
        [
          {
            "node": "Specify Border and Size",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Specify Border and Size": {
      "main": [
        [
          {
            "node": "Split Into Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Split Into Batches": {
      "main": [
        [],
        [
          {
            "node": "Wait Between Batches",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait Between Batches": {
      "main": [
        [
          {
            "node": "Post -> Image",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "65cc9761-28fb-40ae-940f-fe88f2e380ce",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "151305d708accaf9ba7df3ae300984e7c14a108b131ed2d081a3bd48f670f5c4"
  },
  "id": "vK6yG1vzH7szY0DP",
  "tags": []
}